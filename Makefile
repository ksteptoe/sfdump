# --- Makefile (generated by PyScaffold Clickstart) ----------------------------
# Provides:
#   - Auto versioned builds (setuptools_scm)
#   - Linting/formatting via Ruff
#   - Incremental pytest testing via STAMPs
#   - Release helpers (Git tag based)
# -----------------------------------------------------------------------------

.SILENT:
.ONESHELL:
SHELL := $(shell which bash)
.SHELLFLAGS := -eu -o pipefail -c

# Pick a Python: use 'python' if present, else Windows launcher 'py -3'
PYTHON := $(shell command -v python >/dev/null 2>&1 && echo python || echo py -3)

# Main code package
CODE_DIRS   := src/sfdump
CONF_FILES  := pyproject.toml pytest.ini
STAMPS_DIR  := .stamps
NO_CACHE   ?= 0

# Pytest flags
PYTEST         := $(PYTHON) -m pytest
PYTEST_Q       := -q
PYTEST_WARN    := --disable-warnings
# Do NOT enforce fail-under per-stamp; we’ll enforce once at the end
PYTEST_COV_BASE := --cov=sfdump
PYTEST_COV_UNIT := $(PYTEST_COV_BASE) --cov-report= --cov-append
PYTEST_COV_INTEG := $(PYTEST_COV_BASE) --cov-report= --cov-append
PYTEST_XDIST   ?= -n auto
PYTEST_TIMEOUT ?= --timeout=60

# Test directories (align with our layout)
UNIT_DIR    := tests/unit
INTEG_DIR   := tests/integration
SYSTEM_DIR  := tests/system  # live/system tests (opt-in, uncached)

.PHONY: help bootstrap precommit lint format \
        test test-all test-live clean-tests \
        build upload version fetch-tags release-show \
        release-patch release-minor release-major \
        clean run-cli check-clean

help:
	@echo "Common targets:"
	@echo "  make bootstrap           - install .[dev]"
	@echo "  make precommit           - install pre-commit hook"
	@echo "  make lint                - run Ruff checks"
	@echo "  make format              - auto-fix via Ruff"
	@echo "  make test                - run cached unit+integration tests (not live)"
	@echo "  make test-all            - run all non-live tests (no stamps)"
	@echo "  make test-live           - run @live tests only (no cache)"
	@echo "  make build               - build wheel+sdist"
	@echo "  make upload              - upload to PyPI (via Twine)"
	@echo "  make version             - print setuptools_scm inferred version"
	@echo "  make release-show        - show scm ver, installed ver, last Git tag"
	@echo "  make release-patch       - tag vX.Y.(Z+1)"
	@echo "  make release-minor       - tag vX.(Y+1).0"
	@echo "  make release-major       - tag v(X+1).0.0"
	@echo "  make clean               - remove build artifacts"
	@echo "  make run-cli             - run CLI entry point (pass CLI_ARGS=...)"

bootstrap:
	$(PYTHON) -m pip install -U pip setuptools wheel
	$(PYTHON) -m pip install -e ".[dev]"

precommit:
	pre-commit install

# -----------------------------------------------------------------------------#
# Linting / Formatting
lint:
	ruff check .
	ruff format --check .

format:
	ruff check --fix .
	ruff format .

# -----------------------------------------------------------------------------#
# Incremental Testing (cache via stamps)

$(STAMPS_DIR):
	mkdir -p $(STAMPS_DIR)

UNIT_STAMP  := $(STAMPS_DIR)/unit.ok
UNIT_SIG    := $(STAMPS_DIR)/unit.sig
INTEG_STAMP := $(STAMPS_DIR)/integration.ok
INTEG_SIG   := $(STAMPS_DIR)/integration.sig

define compute_dir_sig
{ [ -d "$(1)" ] && find $(1) -type f -not -path "*/__pycache__/*" -print0 || true; } \
| LC_ALL=C sort -z | xargs -0r sha1sum | sha1sum | awk '{print $1}'
endef

define run_pytest
$(PYTHON) -m pytest $(1) $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) $(PYTEST_COV)
endef

$(UNIT_STAMP): | $(STAMPS_DIR)
	@tests_sig=$( $(call compute_dir_sig,$(UNIT_DIR)) ); \
	code_sig=$( $(call compute_dir_sig,$(CODE_DIRS)) ); \
	conf_sig=$( sha1sum $(CONF_FILES) 2>/dev/null | awk '{print $$1}' | sha1sum | awk '{print $$1}' ); \
	new_sig=$( printf "%s\n%s\n%s\n" "$$tests_sig" "$$code_sig" "$$conf_sig" | sha1sum | awk '{print $$1}' ); \
	old_sig=$$(cat $(UNIT_SIG) 2>/dev/null || echo -n); \
	if [ "$(NO_CACHE)" = "1" ] || [ "$$new_sig" != "$$old_sig" ] || [ ! -f $@ ]; then \
	  echo "=== Running unit tests ==="; \
	  rm -f .coverage; \
	  $(PYTHON) -m pytest -q $(UNIT_DIR) -m "not live" $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) $(PYTEST_COV_UNIT); \
	  echo "$$new_sig" > $(UNIT_SIG); \
	  touch $@; \
	else echo "No changes detected; skipping unit tests."; fi

$(INTEG_STAMP): | $(STAMPS_DIR)
	@tests_sig=$( $(call compute_dir_sig,$(INTEG_DIR)) ); \
	code_sig=$( $(call compute_dir_sig,$(CODE_DIRS)) ); \
	conf_sig=$( sha1sum $(CONF_FILES) 2>/dev/null | awk '{print $$1}' | sha1sum | awk '{print $$1}' ); \
	new_sig=$( printf "%s\n%s\n%s\n" "$$tests_sig" "$$code_sig" "$$conf_sig" | sha1sum | awk '{print $$1}' ); \
	old_sig=$$(cat $(INTEG_SIG) 2>/dev/null || echo -n); \
	if [ "$(NO_CACHE)" = "1" ] || [ "$$new_sig" != "$$old_sig" ] || [ ! -f $@ ]; then \
	  echo "=== Running integration tests ==="; \
	  set +e; \
	  $(PYTHON) -m pytest -q $(INTEG_DIR) -m "not live" $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) $(PYTEST_COV_INTEG); \
	  status=$$?; \
	  set -e; \
	  if [ "$$status" -eq 5 ]; then \
	    echo "No integration tests collected; treating as success."; \
	  elif [ "$$status" -ne 0 ]; then \
	    exit $$status; \
	  fi; \
	  echo "$$new_sig" > $(INTEG_SIG); \
	  touch $@; \
	else echo "No changes detected; skipping integration tests."; fi



test: $(UNIT_STAMP) $(INTEG_STAMP)
	@echo "=== Aggregated coverage check (adaptive gate) ==="
	$(PYTHON) -m coverage report
	$(PYTHON) tools/coverage_gate.py
	$(PYTHON) -m coverage xml
	@echo "✅ Unit + Integration tests up-to-date (not live)"

# Full non-live run, no stamps (useful before releases)
test-all:
	$(PYTHON) -m pytest -v -m "not live" $(PYTEST_WARN) $(PYTEST_XDIST) $(PYTEST_TIMEOUT) --cov=sfdump --cov-report=term-missing --cov-report=xml --cov-fail-under=40


# Live tests are explicit & uncached (gentle on API; clearer intent)
test-live:
	SF_LIVE_TESTS=true $(PYTHON) -m pytest -v -m live $(PYTEST_WARN) --timeout=180 --cov=sfdump --cov-report=xml

clean-tests:
	rm -rf $(STAMPS_DIR)

# -----------------------------------------------------------------------------#
# Build & Publish
build:
	$(PYTHON) -m pip install -U build
	$(PYTHON) -m build

upload: build
	$(PYTHON) -m pip install -U twine
	twine check dist/*
	twine upload dist/*

# -----------------------------------------------------------------------------#
# Version & Release helpers (setuptools_scm + Git tags)
fetch-tags:
	git fetch --tags --force --prune 2>/dev/null || true

# Single, non-duplicated tag derivation
LAST_TAG := $(shell git tag --list "v[0-9]*.[0-9]*.[0-9]*" --sort=-version:refname | head -n 1 || echo v0.0.0)
MAJOR    := $(shell echo "$(LAST_TAG)" | sed -E 's/^v([0-9]+)\..*/\1/')
MINOR    := $(shell echo "$(LAST_TAG)" | sed -E 's/^v[0-9]+\.([0-9]+)\..*/\1/')
PATCH    := $(shell echo "$(LAST_TAG)" | sed -E 's/^v[0-9]+\.[0-9]+\.([0-9]+)/\1/')

version:
	@$(PYTHON) -m setuptools_scm || true

release-show: fetch-tags
	@echo "python exe:"; $(PYTHON) -c "import sys; print(sys.executable)"
	@echo "setuptools_scm version:"; $(PYTHON) -m setuptools_scm || echo "(unavailable)"
	@echo "installed dist version:"; $(PYTHON) -c "import importlib.metadata as m; print(m.version('sfdump'))" || echo "(package not installed)"
	@echo "Last Git tag: $(LAST_TAG)"

# Safety check: ensure clean working tree and synced branch before tagging
check-clean:
	@if ! git diff --quiet || ! git diff --cached --quiet; then \
		echo "❌ Working directory not clean. Commit or stash changes before releasing."; \
		git status -s; \
		exit 1; \
	fi
	@if [ "$$(git rev-parse @ 2>/dev/null)" != "$$(git rev-parse @{u} 2>/dev/null)" ]; then \
		echo "❌ Local branch not in sync with upstream (push/pull first)."; \
		exit 1; \
	fi

release-patch: fetch-tags check-clean
	NEW=v$(MAJOR).$(MINOR).$$(($$(printf '%d' $(PATCH)) + 1))
	git tag -a "$$NEW" -m "release: $$NEW"
	git push origin "$$NEW"
	@echo "Tagged $$NEW"

release-minor: fetch-tags check-clean
	NEW=v$(MAJOR).$$(($$(printf '%d' $(MINOR)) + 1)).0
	git tag -a "$$NEW" -m "release: $$NEW"
	git push origin "$$NEW"
	@echo "Tagged $$NEW"

release-major: fetch-tags check-clean
	NEW=v$$(($$(printf '%d' $(MAJOR)) + 1)).0.0
	git tag -a "$$NEW" -m "release: $$NEW"
	git push origin "$$NEW"
	@echo "Tagged $$NEW"

# -----------------------------------------------------------------------------#
# CLI convenience
ROOT ?= .
CLI_ARGS ?=
run-cli:
	sfdump $(ROOT) $(CLI_ARGS)

# -----------------------------------------------------------------------------#
clean:
	rm -rf build dist .eggs *.egg-info .coverage htmlcov .pytest_cache coverage.xml
	find . -type d -name "__pycache__" -prune -exec rm -rf {} +
	rm -rf $(STAMPS_DIR)
